#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/ssl.h>

#include <arpa/inet.h>
#include <poll.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#define PORT 1234
#define LOCALHOST "127.0.0.1"

#ifdef POLLRDHUP
	#define POLLEVENTS (POLLERR | POLLHUP | POLLNVAL | POLLIN | POLLRDHUP)
#else
	#define POLLEVENTS (POLLERR | POLLHUP | POLLNVAL | POLLIN)
#endif

/* Global SSL context */
SSL_CTX *ctx;

#define DEFAULT_BUF_SIZE 64

void print_decrypted_data(char *buf, size_t len)
{
	printf("%.*s", (int)len, buf);
}

/* ------------------------------------------------------------------------ *
 * An instance of this object is created each time a client connection is
 * accepted. It stores the client file descriptor, the SSL objects, and data
 * which is waiting to be either written to socket or encrypted.
 * ------------------------------------------------------------------------ */
struct ssl_client
{
	int fd;

	SSL *ssl;

	BIO *rbio; /* SSL reads from, we write to. */
	BIO *wbio; /* SSL writes to, we read from. */

	/* Bytes waiting to be written to socket. This is data that has been
	 * generated by the SSL object, either due to encryption of user
	 * input, or, writes requires due to peer-requested SSL renegotiation.
	 */
	char *write_buf;
	size_t write_len;

	/* Bytes waiting to be encrypted by the SSL object. */
	char *encrypt_buf;
	size_t encrypt_len;

	/* Method to invoke when unencrypted bytes are available. */
	void (*io_on_read)(char *buf, size_t len);
} client;

/* ------------------------------------------------------------------------ *
 * This enum contols whether the SSL connection needs to initiate the SSL   *
 * handshake.                                                               *
 * ------------------------------------------------------------------------ */
enum ssl_mode {
	SSLMODE_SERVER,
	SSLMODE_CLIENT
};

void ssl_client_init(struct ssl_client *p, int fd, enum ssl_mode mode)
{
	memset(p, 0, sizeof(struct ssl_client));

	p->fd = fd;

	p->rbio = BIO_new(BIO_s_mem());
	p->wbio = BIO_new(BIO_s_mem());
	p->ssl = SSL_new(ctx);

	if (mode == SSLMODE_SERVER)
		SSL_set_accept_state(p->ssl);
	else if (mode == SSLMODE_CLIENT)
		SSL_set_connect_state(p->ssl);

	SSL_set_bio(p->ssl, p->rbio, p->wbio);
	p->io_on_read = print_decrypted_data;
}

void ssl_client_cleanup(struct ssl_client *p)
{
	SSL_free(p->ssl);
	free(p->write_buf);
	free(p->encrypt_buf);
}

int ssl_client_want_write(struct ssl_client *cp)
{
	return (cp->write_len>0);
}

enum sslstatus {
	SSLSTATUS_OK,
	SSLSTATUS_WANT_IO,
	SSLSTATUS_FAIL
};

static enum sslstatus get_sslstatus(SSL* ssl, int n)
{
	switch (SSL_get_error(ssl, n))
	{
		case SSL_ERROR_NONE:
			return SSLSTATUS_OK;
		case SSL_ERROR_WANT_WRITE:
		case SSL_ERROR_WANT_READ:
			return SSLSTATUS_WANT_IO;
		case SSL_ERROR_ZERO_RETURN:
		case SSL_ERROR_SYSCALL:
		default:
			return SSLSTATUS_FAIL;
	}
}

void send_unencrypted_bytes(const char *buf, size_t len)
{
	client.encrypt_buf = realloc(client.encrypt_buf, client.encrypt_len + len);
	memcpy(client.encrypt_buf + client.encrypt_len, buf, len);
	client.encrypt_len += len;
}

void queue_encrypted_bytes(const char *buf, size_t len)
{
	client.write_buf = realloc(client.write_buf, client.write_len + len);
	memcpy(client.write_buf + client.write_len, buf, len);
	client.write_len += len;
}

enum sslstatus do_ssl_handshake()
{
	char buf[DEFAULT_BUF_SIZE];
	enum sslstatus status;

	int n = SSL_do_handshake(client.ssl);
	status = get_sslstatus(client.ssl, n);

	/* Did SSL request to write bytes? */
	if (status == SSLSTATUS_WANT_IO)
		do {
			n = BIO_read(client.wbio, buf, sizeof(buf));
			if (n > 0)
				queue_encrypted_bytes(buf, n);
			else if (!BIO_should_retry(client.wbio))
				return SSLSTATUS_FAIL;
		} while (n > 0);

	return status;
}

int on_read_cb(char *src, size_t len)
{
	char buf[DEFAULT_BUF_SIZE];
	enum sslstatus status;
	int n;

	while (len > 0) {
		n = BIO_write(client.rbio, src, len);
		if (n <= 0)
			return -1;

		src += n;
		len -= n;

		if (!SSL_is_init_finished(client.ssl)) {
			if (do_ssl_handshake() == SSLSTATUS_FAIL)
				return -1;
			if (!SSL_is_init_finished(client.ssl))
				return 0;
		}

		do {
			n = SSL_read(client.ssl, buf, sizeof(buf));
			if (n > 0)
				client.io_on_read(buf, (size_t)n);
		} while (n > 0);

		status = get_sslstatus(client.ssl, n);

		/* Did SSL request to write bytes? This can happen if peer
		 * has requested SSL renegotiation. */
		if (status == SSLSTATUS_WANT_IO)
			do {
				n = BIO_read(client.wbio, buf, sizeof(buf));
				if (n > 0)
					queue_encrypted_bytes(buf, n);
				else if (!BIO_should_retry(client.wbio))
					return -1;
			} while (n > 0);

		if (status == SSLSTATUS_FAIL)
			return -1;
	}

	return 0;
}

int do_encrypt()
{
	char buf[DEFAULT_BUF_SIZE];
	enum sslstatus status;

	if (!SSL_is_init_finished(client.ssl))
		return 0;

	while (client.encrypt_len > 0) {
		int n = SSL_write(client.ssl, client.encrypt_buf, client.encrypt_len);
		status = get_sslstatus(client.ssl, n);

		if (n > 0) {
			if ((size_t)n < client.encrypt_len)
				memmove(client.encrypt_buf,
					client.encrypt_buf + n,
					client.encrypt_len - n);

			client.encrypt_len -= n;
			client.encrypt_buf = realloc(client.encrypt_buf,
							client.encrypt_len);

			do {
				n = BIO_read(client.wbio, buf, sizeof(buf));
				if (n > 0)
					queue_encrypted_bytes(buf, n);
				else if (!BIO_should_retry(client.wbio))
					return -1;
			} while (n > 0);
		}

		if (status == SSLSTATUS_FAIL)
			return -1;

		if (n == 0)
			break;
	}

	return 0;
}

void do_stdin_read()
{
	char buf[DEFAULT_BUF_SIZE];
	ssize_t n = read(STDIN_FILENO, buf, sizeof(buf));
	if (n > 0)
		send_unencrypted_bytes(buf, (size_t)n);
}

int do_sock_read()
{
	char buf[DEFAULT_BUF_SIZE];
	ssize_t n = read(client.fd, buf, sizeof(buf));

	if (n > 0)
		return on_read_cb(buf, (size_t)n);
	return -1;
}

int do_sock_write()
{
	ssize_t n = write(client.fd, client.write_buf, client.write_len);
	if (n > 0) {
		if ((size_t)n<client.write_len)
			memmove(client.write_buf,
				client.write_buf + n,
				client.write_len - n);

		client.write_len -= n;
		client.write_buf = realloc(client.write_buf, client.write_len);
		return 0;
	}

	return -1;
}

static inline void fail(const char *msg)
{
	fprintf(stderr, "** %s\n", msg);
	ERR_print_errors_fp(stderr);
	exit(-1);
}

void ssl_init(const char *certfile, const char *keyfile)
{
	printf("Initialising SSL\n");

	/* SSL initialisation */
	SSL_library_init();
	OpenSSL_add_all_algorithms();
	SSL_load_error_strings();
	ERR_load_BIO_strings();
	ERR_load_crypto_strings();

	ctx = SSL_CTX_new(TLS_method());
	if (!ctx) {
		perror("SSL_CTX_new()");
		exit(-1);
	}

	if (certfile && keyfile) {
		if (SSL_CTX_use_certificate_file(ctx, certfile,  SSL_FILETYPE_PEM) != 1)
			fail("SSL_CTX_use_certificate_file() failed");

		if (SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM) != 1)
			fail("SSL_CTX_use_PrivateKey_filei() failed");

		if (SSL_CTX_check_private_key(ctx) != 1)
			fail("SSL_CTX_check_private_key() failed");

		printf("Certificate and private key verified\n");
	}

	/* SSLv2 & SSLv3 are deprecated and should not be used */
	SSL_CTX_set_options(ctx, SSL_OP_ALL|SSL_OP_NO_SSLv2|SSL_OP_NO_SSLv3);
}

